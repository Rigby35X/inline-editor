'use client'

import { createContext, useContext, useReducer, useEffect, ReactNode } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'

interface EditorState {
  isEditing: boolean
  mode: 'content' | 'style'
  activeElement: string | null
  hasUnsavedChanges: boolean
  isPreviewMode: boolean
  sessionId: string | null
  userId: string
  elements: Record<string, any>
  pageSlug: string
}

type EditorAction = 
  | { type: 'TOGGLE_EDITING' }
  | { type: 'SET_MODE'; mode: 'content' | 'style' }
  | { type: 'SET_ACTIVE_ELEMENT'; elementId: string | null }
  | { type: 'UPDATE_ELEMENT'; elementId: string; data: any }
  | { type: 'TOGGLE_PREVIEW' }
  | { type: 'SAVE_CHANGES' }
  | { type: 'SET_SESSION'; sessionId: string }
  | { type: 'SET_PAGE_SLUG'; slug: string }
  | { type: 'HYDRATE_ELEMENTS'; elements: Record<string, any> }

const initialState: EditorState = {
  isEditing: false,
  mode: 'content',
  activeElement: null,
  hasUnsavedChanges: false,
  isPreviewMode: false,
  sessionId: null,
  userId: 'user-1',
  elements: {},
  pageSlug: 'home',
}

function editorReducer(state: EditorState, action: EditorAction): EditorState {
  switch (action.type) {
    case 'TOGGLE_EDITING':
      return { ...state, isEditing: !state.isEditing }
    case 'SET_MODE':
      return { ...state, mode: action.mode }
    case 'SET_ACTIVE_ELEMENT':
      return { ...state, activeElement: action.elementId }
    case 'UPDATE_ELEMENT':
      return {
        ...state,
        elements: {
          ...state.elements,
          [action.elementId]: { ...state.elements[action.elementId], ...action.data }
        },
        hasUnsavedChanges: true
      }
    case 'TOGGLE_PREVIEW':
      return { ...state, isPreviewMode: !state.isPreviewMode }
    case 'SAVE_CHANGES':
      return { ...state, hasUnsavedChanges: false }
    case 'SET_SESSION':
      return { ...state, sessionId: action.sessionId }
    case 'SET_PAGE_SLUG':
      return { ...state, pageSlug: action.slug }
    case 'HYDRATE_ELEMENTS':
      return { ...state, elements: { ...action.elements } }
    default:
      return state
  }
}

const EditorContext = createContext<{
  state: EditorState
  dispatch: React.Dispatch<EditorAction>
} | null>(null)

export function EditorProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(editorReducer, initialState)
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // Determine page slug ('' -> 'home', '/animals' -> 'animals', etc.)
  useEffect(() => {
    const slug = pathname === '/' ? 'home' : pathname.replace(/^\/|\/$/g, '')
    if (slug !== state.pageSlug) {
      dispatch({ type: 'SET_PAGE_SLUG', slug })
    }
  }, [pathname, state.pageSlug])

  // Hydrate page elements from API
  useEffect(() => {
    const load = async () => {
      if (!state.pageSlug) return
      try {
        const res = await fetch(`/api/pages/${state.pageSlug}/elements`, { cache: 'no-store' })
        if (res.ok) {
          const data = await res.json()
          // data.elements expected to be a mapping
          dispatch({ type: 'HYDRATE_ELEMENTS', elements: data.elements || {} })
        }
      } catch {
        // ignore
      }
    }
    load()
  }, [state.pageSlug])

  // Enable edit mode by query param
  useEffect(() => {
    const editParam = searchParams.get('edit')
    if (editParam === 'true' && !state.isEditing) {
      dispatch({ type: 'TOGGLE_EDITING' })
      dispatch({ type: 'SET_SESSION', sessionId: `session-${Date.now()}` })
    }
  }, [searchParams, state.isEditing])

  // Warn on unload with unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (state.hasUnsavedChanges) {
        e.preventDefault()
        e.returnValue = ''
      }
    }
    window.addEventListener('beforeunload', handleBeforeUnload)
    return () => window.removeEventListener('beforeunload', handleBeforeUnload)
  }, [state.hasUnsavedChanges])

  return (
    <EditorContext.Provider value={{ state, dispatch }}>
      {children}
    </EditorContext.Provider>
  )
}

export function useEditor() {
  const context = useContext(EditorContext)
  if (!context) {
    throw new Error('useEditor must be used within EditorProvider')
  }
  return context
}
